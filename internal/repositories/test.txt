func (h *ProductHandlers) UpdateProduct(ctx *gin.Context) {
    responder := models.NewResponse(ctx)
    productID := ctx.Param("id")

    // Validasi productID sebagai UUID
    if _, err := uuid.Parse(productID); err != nil {
        responder.BadRequest("Invalid product ID format", nil)
        return
    }

    // Bind form data
    var formBody models.ProductRequest
    if err := ctx.ShouldBind(&formBody); err != nil {
        log.Println("Binding error:", err.Error())
        responder.BadRequest("Invalid request data", gin.H{"error": err.Error()})
        return
    }

    // Get old images
    oldImages, err := h.repo.GetListImageProduct(ctx.Request.Context(), productID)
    if err != nil {
        log.Println("Failed to get old images:", err)
        responder.InternalServerError("Failed to get product images", nil)
        return
    }

    // Handle image upload (jika ada)
    var newImageNames []string
    form, err := ctx.MultipartForm()
    if err == nil { // Jika ada file yang diupload
        imageFiles := form.File["images"]
        
        for _, file := range imageFiles {
            if !isImage(file) {
                log.Printf("File %s is not a valid image", file.Filename)
                continue
            }

            filename, _, err := fileHandling(ctx, file)
            if err != nil {
                log.Printf("Failed to save image %s: %v", file.Filename, err)
                continue
            }

            newImageNames = append(newImageNames, filename)
        }
    }

    // Update product data
    err = h.repo.UpdateProduct(ctx.Request.Context(), productID, &formBody, newImageNames)
    if err != nil {
        log.Println("Failed to update product:", err)
        
        // Cleanup: hapus new images yang sudah diupload tapi gagal update
        for _, img := range newImageNames {
            os.Remove(filepath.Join("public", "product-image", img))
        }
        
        responder.InternalServerError("Failed to update product", nil)
        return
    }

    // Delete old images yang sudah diganti
    if len(newImageNames) > 0 {
        for _, oldImg := range oldImages {
            os.Remove(filepath.Join("public", "product-image", oldImg))
        }
    }

    responder.Success("Product updated successfully", gin.H{
        "product_id": productID,
        "new_images": newImageNames,
    })
}

// GetListImageProduct di Repository
func (r *productRepository) GetListImageProduct(ctx context.Context, productID string) ([]string, error) {
    query := `SELECT path FROM product_images WHERE product_id = $1`
    
    rows, err := r.DB.Query(ctx, query, productID)
    if err != nil {
        return nil, err
    }
    defer rows.Close()

    var images []string
    for rows.Next() {
        var path string
        if err := rows.Scan(&path); err != nil {
            return nil, err
        }
        images = append(images, path)
    }

    return images, nil
}

// UpdateProduct di Repository
func (r *productRepository) UpdateProduct(ctx context.Context, productID string, product *models.ProductRequest, newImages []string) error {
    tx, err := r.DB.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback(ctx)

    // Update product info
    _, err = tx.Exec(ctx,
        `UPDATE products SET 
            name = $1, 
            description = $2, 
            price = $3,
            stock = $4,
            updated_at = NOW()
         WHERE id = $5`,
        product.Name,
        product.Description,
        product.Price,
        product.Stock,
        productID,
    )
    if err != nil {
        return fmt.Errorf("failed to update product: %w", err)
    }

    // Handle new images
    if len(newImages) > 0 {
        // Delete old images from DB
        _, err = tx.Exec(ctx, "DELETE FROM product_images WHERE product_id = $1", productID)
        if err != nil {
            return fmt.Errorf("failed to delete old images: %w", err)
        }

        // Insert new images
        var queryBuilder strings.Builder
        queryBuilder.WriteString("INSERT INTO product_images (product_id, path) VALUES ")
        
        var values []interface{}
        for i, img := range newImages {
            if i > 0 {
                queryBuilder.WriteString(", ")
            }
            queryBuilder.WriteString(fmt.Sprintf("($1, $%d)", i+2))
            values = append(values, img)
        }

        _, err = tx.Exec(ctx, queryBuilder.String(), append([]interface{}{productID}, values...)...)
        if err != nil {
            return fmt.Errorf("failed to insert new images: %w", err)
        }
    }

    return tx.Commit(ctx)
}






handle parsial

func (r *productRepository) UpdateProductPartial(ctx context.Context, productID string, updateData *models.ProductUpdateRequest, newImages []string) error {
    tx, err := r.DB.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback(ctx)

    // Build dynamic update query untuk product
    var queryParts []string
    var params []interface{}
    paramCount := 1

    if updateData.Name != nil {
        queryParts = append(queryParts, fmt.Sprintf("name = $%d", paramCount))
        params = append(params, *updateData.Name)
        paramCount++
    }
    if updateData.Description != nil {
        queryParts = append(queryParts, fmt.Sprintf("description = $%d", paramCount))
        params = append(params, *updateData.Description)
        paramCount++
    }
    if updateData.Price != nil {
        queryParts = append(queryParts, fmt.Sprintf("price = $%d", paramCount))
        params = append(params, *updateData.Price)
        paramCount++
    }
    if updateData.Stock != nil {
        queryParts = append(queryParts, fmt.Sprintf("stock = $%d", paramCount))
        params = append(params, *updateData.Stock)
        paramCount++
    }
    if updateData.CategoryID != nil {
        queryParts = append(queryParts, fmt.Sprintf("category_id = $%d", paramCount))
        params = append(params, *updateData.CategoryID)
        paramCount++
    }

    // Jika ada field yang diupdate
    if len(queryParts) > 0 {
        query := fmt.Sprintf(`
            UPDATE products 
            SET %s, updated_at = NOW()
            WHERE id = $%d`,
            strings.Join(queryParts, ", "),
            paramCount)
        
        params = append(params, productID)
        
        _, err := tx.Exec(ctx, query, params...)
        if err != nil {
            return fmt.Errorf("failed to update product: %w", err)
        }
    }

    // Handle image updates jika ada gambar baru atau keep_images
    if len(newImages) > 0 || len(updateData.KeepImages) > 0 {
        // Gabungkan gambar baru dan yang dipertahankan
        allImages := append(updateData.KeepImages, newImages...)

        // Delete images yang tidak di-include
        _, err = tx.Exec(ctx, `
            DELETE FROM product_images 
            WHERE product_id = $1 AND path NOT IN (
                SELECT unnest($2::text[])
            )`, productID, allImages)
        if err != nil {
            return fmt.Errorf("failed to delete old images: %w", err)
        }

        // Insert new images yang belum ada
        if len(newImages) > 0 {
            _, err = tx.Exec(ctx, `
                INSERT INTO product_images (product_id, path)
                SELECT $1, unnest($2::text[])
                WHERE NOT EXISTS (
                    SELECT 1 FROM product_images 
                    WHERE product_id = $1 AND path = unnest($2::text[])
                )`, productID, newImages)
            if err != nil {
                return fmt.Errorf("failed to insert new images: %w", err)
            }
        }
    }

    return tx.Commit(ctx)
}



func (h *ProductHandlers) UpdateProductPartial(ctx *gin.Context) {
    responder := models.NewResponse(ctx)
    productID := ctx.Param("id")

    // Validasi productID
    if _, err := uuid.Parse(productID); err != nil {
        responder.BadRequest("Invalid product ID format", nil)
        return
    }

    // Bind request body
    var updateData models.ProductUpdateRequest
    if err := ctx.ShouldBind(&updateData); err != nil {
        responder.BadRequest("Invalid request data", gin.H{"error": err.Error()})
        return
    }

    // Process file uploads jika ada
    var newImageNames []string
    form, _ := ctx.MultipartForm()
    if form != nil {
        imageFiles := form.File["images"]
        for _, file := range imageFiles {
            if !isImage(file) {
                continue
            }
            filename, _, err := fileHandling(ctx, file)
            if err != nil {
                continue
            }
            newImageNames = append(newImageNames, filename)
        }
    }

    // Update product data
    err := h.repo.UpdateProductPartial(ctx.Request.Context(), productID, &updateData, newImageNames)
    if err != nil {
        // Cleanup new images if update fails
        for _, img := range newImageNames {
            os.Remove(filepath.Join("public", "product-image", img))
        }
        responder.InternalServerError("Failed to update product", nil)
        return
    }

    responder.Success("Product updated successfully", nil)
}












type ProductUpdateRequest struct {
    Name        *string  `json:"name,omitempty"`
    Description *string  `json:"description,omitempty"`
    Price       *float64 `json:"price,omitempty"`
    Stock       *int     `json:"stock,omitempty"`
    CategoryID  *string  `json:"category_id,omitempty"`
    KeepImages  []string `json:"keep_images,omitempty"` // Untuk gambar yang dipertahankan
}




func (h *ProductHandlers) UpdateProductPartial(ctx *gin.Context) {
    responder := models.NewResponse(ctx)
    productID := ctx.Param("id")

    // Validasi productID
    if _, err := uuid.Parse(productID); err != nil {
        responder.BadRequest("Invalid product ID format", nil)
        return
    }

    // Bind request body
    var updateData models.ProductUpdateRequest
    if err := ctx.ShouldBind(&updateData); err != nil {
        responder.BadRequest("Invalid request data", gin.H{"error": err.Error()})
        return
    }

    // Process file uploads jika ada
    var newImageNames []string
    form, _ := ctx.MultipartForm()
    if form != nil {
        imageFiles := form.File["images"]
        for _, file := range imageFiles {
            if !isImage(file) {
                continue
            }
            filename, _, err := fileHandling(ctx, file)
            if err != nil {
                continue
            }
            newImageNames = append(newImageNames, filename)
        }
    }

    // Update product data
    err := h.repo.UpdateProductPartial(ctx.Request.Context(), productID, &updateData, newImageNames)
    if err != nil {
        // Cleanup new images if update fails
        for _, img := range newImageNames {
            os.Remove(filepath.Join("public", "product-image", img))
        }
        responder.InternalServerError("Failed to update product", nil)
        return
    }

    responder.Success("Product updated successfully", nil)
}




func (r *productRepository) UpdateProductPartial(ctx context.Context, productID string, updateData *models.ProductUpdateRequest, newImages []string) error {
    tx, err := r.DB.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback(ctx)

    // Build dynamic update query untuk product
    var queryParts []string
    var params []interface{}
    paramCount := 1

    if updateData.Name != nil {
        queryParts = append(queryParts, fmt.Sprintf("name = $%d", paramCount))
        params = append(params, *updateData.Name)
        paramCount++
    }
    if updateData.Description != nil {
        queryParts = append(queryParts, fmt.Sprintf("description = $%d", paramCount))
        params = append(params, *updateData.Description)
        paramCount++
    }
    if updateData.Price != nil {
        queryParts = append(queryParts, fmt.Sprintf("price = $%d", paramCount))
        params = append(params, *updateData.Price)
        paramCount++
    }
    if updateData.Stock != nil {
        queryParts = append(queryParts, fmt.Sprintf("stock = $%d", paramCount))
        params = append(params, *updateData.Stock)
        paramCount++
    }
    if updateData.CategoryID != nil {
        queryParts = append(queryParts, fmt.Sprintf("category_id = $%d", paramCount))
        params = append(params, *updateData.CategoryID)
        paramCount++
    }

    // Jika ada field yang diupdate
    if len(queryParts) > 0 {
        query := fmt.Sprintf(`
            UPDATE products 
            SET %s, updated_at = NOW()
            WHERE id = $%d`,
            strings.Join(queryParts, ", "),
            paramCount)
        
        params = append(params, productID)
        
        _, err := tx.Exec(ctx, query, params...)
        if err != nil {
            return fmt.Errorf("failed to update product: %w", err)
        }
    }

    // Handle image updates jika ada gambar baru atau keep_images
    if len(newImages) > 0 || len(updateData.KeepImages) > 0 {
        // Gabungkan gambar baru dan yang dipertahankan
        allImages := append(updateData.KeepImages, newImages...)

        // Delete images yang tidak di-include
        _, err = tx.Exec(ctx, `
            DELETE FROM product_images 
            WHERE product_id = $1 AND path NOT IN (
                SELECT unnest($2::text[])
            )`, productID, allImages)
        if err != nil {
            return fmt.Errorf("failed to delete old images: %w", err)
        }

        // Insert new images yang belum ada
        if len(newImages) > 0 {
            _, err = tx.Exec(ctx, `
                INSERT INTO product_images (product_id, path)
                SELECT $1, unnest($2::text[])
                WHERE NOT EXISTS (
                    SELECT 1 FROM product_images 
                    WHERE product_id = $1 AND path = unnest($2::text[])
                )`, productID, newImages)
            if err != nil {
                return fmt.Errorf("failed to insert new images: %w", err)
            }
        }
    }

    return tx.Commit(ctx)
}










func (h *ProductHandlers) UpdateProduct(ctx *gin.Context) {
    responder := models.NewResponse(ctx)
    productID := ctx.Param("id")

    // Validasi productID
    if _, err := uuid.Parse(productID); err != nil {
        responder.BadRequest("Invalid product ID format", nil)
        return
    }

    // Bind form data
    var updateData models.ProductUpdateRequest
    if err := ctx.ShouldBind(&updateData); err != nil {
        responder.BadRequest("Invalid request data", gin.H{"error": err.Error()})
        return
    }

    // Get current images from database
    currentImages, err := h.repo.GetListImageProduct(ctx.Request.Context(), productID)
    if err != nil {
        responder.InternalServerError("Failed to get current images", nil)
        return
    }

    // Process file uploads (3 gambar baru)
    var newImageNames []string
    form, _ := ctx.MultipartForm()
    if form != nil {
        imageFiles := form.File["images"]
        
        // Validasi jumlah gambar
        if len(imageFiles) != 3 {
            responder.BadRequest("Exactly 3 images are required", nil)
            return
        }

        for _, file := range imageFiles {
            if !isImage(file) {
                responder.BadRequest("Invalid image file type", nil)
                return
            }

            filename, _, err := fileHandling(ctx, file)
            if err != nil {
                responder.InternalServerError("Failed to save image", nil)
                return
            }
            newImageNames = append(newImageNames, filename)
        }
    }

    // Bandingkan gambar lama dan baru
    isSame, imagesForUpdate := compareImages(currentImages, newImageNames)

    if !isSame {
        // Hapus semua gambar lama
        for _, img := range currentImages {
            os.Remove(filepath.Join("public", "product-image", img))
        }

        // Update database dengan gambar baru
        err = h.repo.ReplaceAllProductImages(ctx.Request.Context(), productID, newImageNames)
        if err != nil {
            // Cleanup: hapus gambar baru jika update gagal
            for _, img := range newImageNames {
                os.Remove(filepath.Join("public", "product-image", img))
            }
            responder.InternalServerError("Failed to update product images", nil)
            return
        }
    } else {
        // Gambar sama, hapus gambar baru yang diupload
        for _, img := range newImageNames {
            os.Remove(filepath.Join("public", "product-image", img))
        }
    }

    responder.Success("Product updated successfully", gin.H{
        "product_id": productID,
        "images_updated": !isSame,
        "new_images": newImageNames,
    })
}